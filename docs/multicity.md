# Документация по функционалу "Мультигород"

## Общее описание
Система позволяет сайту работать в режиме мультигорода, где контент (страницы, врачи, услуги) может быть привязан к конкретным городам. Города определяются через URL-префикс (например, `site.ru/spb/contacts`).

## 1. База данных
### Таблица `cities`
Хранит список городов.
- `slug`: Уникальный идентификатор города в URL (например, `spb`, `kazan`).
- `is_default`: Флаг основного города (обычно Москва). Для него URL-префикс не используется.
- `active`: Флаг активности города.

### Связи (Pivot Tables)
Контент привязывается к городам через таблицы "многие-ко-многим":
- `city_page` (Страницы)
- `city_doctor` (Врачи)
- `city_service` (Услуги)
- `city_promotion` (Акции)
- `city_block` (Блоки)

## 2. Логика работы (Backend)

### Определение города (`SetCityMiddleware`)
Middleware `App\Http\Middleware\SetCityMiddleware` выполняется при каждом запросе:
1.  Проверяет наличие слага города в URL.
2.  Если слаг есть:
    *   Ищет город в БД.
    *   Если город **дефолтный**, делает 301 редирект на URL без префикса (SEO требование).
    *   Устанавливает текущий город в `CityService`.
3.  Если слага нет, устанавливает дефолтный город.
4.  Делится переменной `$currentCity` со всеми View.

### Сервис (`CityService`)
`App\Services\CityService` — синглтон, который хранит состояние текущего города на протяжении всего жизненного цикла запроса.

### Фильтрация меню (`MenuService`)
Пункты меню могут быть привязаны к городам через настройки в админ-панели.
- Если пункту меню назначены города, он будет отображаться **только** в этих городах.
- Если города не назначены, пункт меню отображается **во всех** городах.
- Логика реализована в `App\Services\MenuService` с рекурсивной фильтрацией вложенных пунктов.

### Фильтрация контента (`HasCityScope`)
Трейт `App\Models\Traits\HasCityScope` автоматически фильтрует запросы к моделям (Page, Doctor и т.д.):
- Если модель имеет связь с городами, она будет показана только если:
    1.  Она **не привязана** ни к какому городу (общий контент).
    2.  ИЛИ она привязана к **текущему** выбранному городу.

### Формирование ссылок

#### 1. Глобальные хелперы

*   `city_route('name', $params)`: Используется вместо стандартного `route()`. Автоматически добавляет префикс `/slug/`, если город выбран и не является дефолтным.
*   `home_route()`: Возвращает ссылку на главную страницу текущего города (например, `/spb` или `/`).

#### 2. Меню (`MenuService`)
`App\Services\MenuService` автоматически добавляет префикс города к пунктам меню.

#### 3. Модели (`getUrl` / `url` attribute)
Методы получения URL в моделях (`Page`, `Doctor`) обновлены для использования `city_route`.

```php
// Пример из Doctor.php
public function url(): Attribute
{
    return Attribute::get(
        fn() => city_route('doctor.show', ['handle' => $this->handle ?? $this->id])
    )->shouldCache();
}
```

#### 4. Blade шаблоны
В местах ручного формирования ссылок используйте хелперы `city_route()` или `home_route()`.

```php
<a href="{{ home_route() }}">Главная</a>
```

### Блоки (`Block`)
Блоки контента, привязанные к страницам, также поддерживают привязку к городам. Это позволяет использовать одну страницу (например, "Контакты") для всех городов, но показывать разные блоки (карты, адреса) в зависимости от города.
- Реализовано через таблицу `city_block` и трейт `HasCityScope`.
- В админ-панели в ресурсе Блока добавлено поле выбора городов.
- Реализован функционал **копирования блоков** (`ReplicateBlockAction`), который:
    - Позволяет дублировать блок со всеми настройками.
    - Копирует все медиафайлы (изображения).
    - Предлагает модальное окно для выбора городов новой копии (по умолчанию выбраны города оригинала).

## 3. Управление ценами и услугами (Service & Prices)

### Новая архитектура (ServicePriceService)
Мы перешли от получения цен из внешнего источника (1С/JSON) к хранению их в базе данных.
- **ServiceResource**: Управляет корневыми категориями услуг (`parent_id` is null).
- **ChildrenRelationManager**: Управляет дочерними услугами и их ценами.
- **ServicePrice**: Модель для хранения цен. Привязана к `Service` и `City`.
    - `city_id`: ID города или `null` (глобальная цена).
    - `price`: Текущая цена.
    - `old_price`: Старая цена (для отображения скидки).
    - `price_from`: Флаг "от" (цена от...).

### Получение цен (`ServicePriceService`)
Сервис `App\Services\ServicePriceService` отвечает за получение дерева услуг с актуальными ценами для текущего города.
- Метод `getServicesWithPrices()`:
    1.  Загружает дерево услуг (категории -> дочерние услуги -> цены).
    2.  Для каждой дочерней услуги находит наиболее подходящую цену:
        - Сначала ищет цену для текущего города (`city_id` совпадает).
        - Если нет, берет глобальную цену (`city_id` is null).
    3.  Кеширует результат с учетом города.

### Импорт данных
- Команда `app:import-services-legacy`: Импортирует структуру и цены из старого источника (`Clinic::prices()`) в базу данных.
    - Идемпотентна (можно запускать многократно).
    - Сохраняет UUID услуг для совместимости.
    - Поддерживает старую цену (`price2` -> `old_price`).

## 4. Кеширование

### Кеширование контента
При кешировании контента, зависящего от города (например, списки врачей или услуг), **обязательно** включайте слаг города в ключ кеша.

**Важно:** Это касается и глобальных хелперов/сервисов. Например, список всех врачей для меню должен кешироваться раздельно для каждого города, чтобы учитывались привязки врачей к городам.

```php
// Пример из App\Helpers\Doctors
$slug = $cityService->getCurrentCity()?->slug ?? 'global';
// Для админки или консоли можно использовать 'all'
return Cache::remember("doctors-{$slug}", ...);
```

```php
// Пример из PageController
$cityKey = app(\App\Services\CityService::class)->getCurrentCity()?->slug ?? 'global';
$cacheKey = "doctors-page-{$cityKey}-" . request('page', 1);
```

### Сброс кеша
При обновлении моделей (`Doctor`, `Service`, `ServicePrice`) сбрасывайте кеши для **всех** активных городов.

```php
// Пример очистки кеша услуг (в модели Service и ServicePrice)
public static function clearServicesCache(): void
{
    $cityService = app(\App\Services\CityService::class);
    $slugs = $cityService->getActiveCities()->pluck('slug')->push('global');

    foreach ($slugs as $slug) {
        \Illuminate\Support\Facades\Cache::forget("services-with-prices-{$slug}");
    }
}
```

## 5. Обработка ошибок (404)
В контроллерах, работающих с моделями, привязанными к городам (`HasCityScope`), необходимо проверять результат поиска модели. Если модель не найдена (например, врач не привязан к текущему городу), следует явно возвращать 404 ошибку, чтобы избежать попыток обращения к свойствам `null`.

```php
$doctor = Doctor::query()->where('handle', $handle)->first();
if (!$doctor) {
    abort(404);
}
```

## 6. Frontend (Vue.js & Blade)

### Переключатель городов (`CitySwitcher`)
Компонент `resources/js/components/CitySwitcher/CitySwitcher.vue`.
- Отображает текущий город.
- Показывает выпадающий список доступных городов.
- Ссылки генерируются на сервере и передаются в компонент, учитывая текущий URL пользователя.

### Компоненты цен
- `full-price-list.blade.php`: Отображает полный прайс-лист. Получает данные через View Composer из `ServicePriceService`.
- `price-list.blade.php`: Блок прайс-листа на странице услуги. Использует метод `getPricesAttribute` модели `Block`, который теперь также использует новую структуру данных (через связь с `Service`).
- `price-service.blade.php`: Отображение цены конкретной услуги.

## 7. Как пользоваться разработчику

### Добавление поддержки городов для новой модели
1.  Создать pivot-таблицу `city_newmodel`.
2.  Добавить трейт `HasCityScope` в модель.
3.  Добавить отношение `belongsToMany(City::class)` в модель.
    *   **Важно:** Если имя модели по алфавиту идет раньше `City` (например, `Block`), Laravel будет искать таблицу `block_city`. В этом случае нужно явно указать имя таблицы во втором аргументе: `return $this->belongsToMany(City::class, 'city_block');`.

### Работа с путями (Request Path)
Метод `request()->path()` возвращает полный путь, включая префикс города (например, `kirov/stati`). Если логика зависит от пути (например, поиск категории по slug), необходимо очищать путь от префикса.

**Пример в контроллере (`PostController`):**
```php
$path = $request->path();
// ... очистка префикса ...

// Важно: При поиске категории по пути, учитывайте, что для вложенных страниц (например, тегов)
// путь может не совпадать с handle категории.
if (!$handle) { // Только если это не страница тега
    $categoryCurrent = $categories->where('handle', $path)->first();
    if (!$categoryCurrent) abort(404);
}
```

## 8. SEO и Sitemap

### XML карта сайта (`sitemap.xml`)
Маршрут `/sitemap.xml` (и `/city/sitemap.xml`) обрабатывается специально для поддержки мультигородов:
1.  **Определение города**:
    - Пытается получить параметр маршрута `{city}`.
    - Если параметр отсутствует (например, из-за особенностей маршрутизатора Laravel), происходит ручной парсинг сегментов URL (fallback).
2.  **Отдача файла**:
    - Для глобального контекста отдается `public/sitemap.xml`.
    - Для конкретного города отдается `public/sitemap-{city}.xml`.
    - Если специфичный файл не найден, возвращается 404.

### HTML карта сайта (`sitemap.html`)
Страница `/sitemap.html` также поддерживает префиксы городов (например, `/kirov/sitemap.html`).
- Маршрут находится внутри группы `$contentRoutes`, что позволяет ему наследовать текущий город.
- В шаблоне `sitemap-html.blade.php` все ссылки генерируются с учетом текущего города:
    - Использование `$page->getUrl()` для страниц.
    - Использование хелпера `city_route()` для других маршрутов (например, тегов).

## 9. Настройки и Контакты (Settings -> Cities)

Ранее общие настройки (телефон, адрес, соцсети) хранились в глобальных настройках (`GeneralSettings`). Теперь они перенесены в таблицу `cities`, что позволяет задавать свои контакты для каждого города.

### Перенесенные поля
Следующие поля теперь находятся в модели `City` (таблица `cities`):
- `phone` (Телефон)
- `email` (Email)
- `address` (Адрес)
- `postal_code` (Индекс)
- `coordinates` (Координаты)
- `schedule` (Режим работы)
- `metro` (Метро)
- `social_links` (Соцсети: vk, telegram, youtube и др.)
- `header_scripts`, `body_scripts` (Скрипты аналитики и метрик)
- `special_schedule` (Спец. режим работы)

### Использование в коде
Вместо инъекции `GeneralSettings` используйте текущий город из `CityService` или переменную `$currentCity` в шаблонах.

**Было (неправильно):**
```php
// GeneralSettings больше не содержит контактов
public function index(GeneralSettings $settings) {
    return $settings->phone; // Ошибка: свойства не существует
}
```

**Стало (правильно):**
```php
$city = app(CityService::class)->getCurrentCity();
// Обращаемся к свойствам модели City
$phone = $city->phone;
$address = $city->address;
```

В Blade шаблонах доступна глобальная переменная `$currentCity`:
```blade
<a href="tel:{{ $currentCity->phone }}">{{ $currentCity->phone }}</a>
```

## 10. Schema.org Разметка

Сервис `App\Services\Schema\Schema.php` адаптирован для работы с мультигородами.

### Основные изменения
1.  **LocalBusiness & MedicalOrganization**:
    - Используют телефон, адрес, координаты и режим работы текущего города (`$city->phone`, `$city->address`, etc.).
    - Социальные ссылки берутся из настроек города.
2.  **Physician (Врачи)**:
    - Использует телефон текущего города.
    - Режим работы и карта генерируются динамически на основе данных города (ранее были захардкожены).
    - Карта формируется как ссылка на Яндекс.Карты с координатами города.

### Реализация
В методах сервиса используется `CityService` для получения контекста:

```php
public function physician(Doctor $doctor, ?GeneralSettings $settings = null): Physician
{
    $city = app(\App\Services\CityService::class)->getCurrentCity();
    // ... использование $city->phone, $city->schedule и т.д.
}
```
